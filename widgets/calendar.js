/**
 * ðŸ¤– AI-Generated Project: Minimalist Homepage
 * Generated by: Claude Sonnet 4 (Anthropic)
 * Date: 2024
 * Description: Calendar Widget - Mini calendar with event and task management
 * Tech Stack: Vanilla HTML/CSS/JS + Tailwind CSS
 * License: MIT
 */

// ============================================================================
// MINI CALENDAR WIDGET (Ticket 10)
// ============================================================================

let currentCalendarDate = new Date();

// Calendar events data
let calendarEvents = {};

/**
 * Gets the number of days in a month
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @returns {number} Number of days in the month
 */
function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}

/**
 * Gets the day of week for the first day of a month
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @returns {number} Day of week (0-6, where 0 is Sunday)
 */
function getFirstDayOfMonth(year, month) {
    return new Date(year, month, 1).getDay();
}

/**
 * Gets a date key for localStorage storage
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @param {number} day - Day of month
 * @returns {string} Date key in YYYY-MM-DD format
 */
function getDateKey(year, month, day) {
    return new Date(year, month, day).toISOString().split('T')[0];
}

/**
 * Loads calendar events from localStorage
 */
function loadCalendarEvents() {
    const saved = localStorage.getItem('calendarEvents');
    if (saved) {
        calendarEvents = JSON.parse(saved);
    }
}

/**
 * Saves calendar events to localStorage
 */
function saveCalendarEvents() {
    localStorage.setItem('calendarEvents', JSON.stringify(calendarEvents));
}

/**
 * Adds an event to a specific date
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 * @param {string} eventText - Event description
 */
function addCalendarEvent(dateKey, eventText) {
    if (eventText.trim()) {
        calendarEvents[dateKey] = eventText.trim();
        saveCalendarEvents();
    }
}

/**
 * Removes an event from a specific date
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 */
function removeCalendarEvent(dateKey) {
    delete calendarEvents[dateKey];
    saveCalendarEvents();
}

/**
 * Shows event input modal
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 * @param {string} currentEvent - Current event text (if editing)
 */
function showEventModal(dateKey, currentEvent = '') {
    const eventText = prompt(
        currentEvent ? 'Edit event:' : 'Add event for this date:',
        currentEvent
    );
    
    if (eventText !== null) {
        if (eventText.trim()) {
            addCalendarEvent(dateKey, eventText);
        } else if (currentEvent) {
            removeCalendarEvent(dateKey);
        }
        renderCalendar();
    }
}

/**
 * Shows task input modal
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 * @param {Array} tasksForDate - Array of task objects for this date
 */
function showTaskModal(dateKey, tasksForDate) {
    const taskText = prompt(
        tasksForDate.length > 0 ? 'Edit tasks for this date:' : 'Add tasks for this date:',
        tasksForDate.map(task => `${task.text} (Completed: ${task.completed ? 'Yes' : 'No'})`).join('\n')
    );

    if (taskText !== null) {
        const newTasks = taskText.split('\n').map(line => {
            const parts = line.trim().split(' ');
            const text = parts.slice(0, -1).join(' '); // Get text before completion status
            const completed = parts.slice(-1)[0] === 'Completed: Yes';
            return { text: text, completed: completed };
        });

        // Filter out empty lines and invalid lines
        const validTasks = newTasks.filter(task => task.text.trim() !== '');

        if (validTasks.length > 0) {
            window.taskStore.addTasksForDate(dateKey, validTasks);
            renderTodos(); // Re-render todos to show new tasks
            renderCalendar(); // Re-render calendar to show task indicators
        } else if (tasksForDate.length > 0) {
            // If user cancelled and there were tasks, remove them
            window.taskStore.deleteTasksForDate(dateKey);
            renderTodos();
            renderCalendar();
        }
    }
}

/**
 * Generates calendar days for a given month
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @returns {Array} Array of day objects
 */
function generateCalendarDays(year, month) {
    const daysInMonth = getDaysInMonth(year, month);
    const firstDayOfMonth = getFirstDayOfMonth(year, month);
    const days = [];
    
    // Add empty cells for days before the first day of the month
    for (let i = 0; i < firstDayOfMonth; i++) {
        days.push({ day: '', isEmpty: true });
    }
    
    // Add days of the month
    for (let day = 1; day <= daysInMonth; day++) {
        const dateKey = getDateKey(year, month, day);
        const isToday = new Date().toDateString() === new Date(year, month, day).toDateString();
        const hasEvent = calendarEvents[dateKey];
        
        // Check for tasks on this date using task store
        const tasksForDate = window.taskStore.getTasksByDate(dateKey);
        const hasTasks = tasksForDate.length > 0;
        const completedTasks = tasksForDate.filter(task => task.completed).length;
        const pendingTasks = tasksForDate.length - completedTasks;
        
        days.push({ 
            day: day, 
            isEmpty: false, 
            isToday: isToday,
            isCurrentMonth: true,
            dateKey: dateKey,
            hasEvent: hasEvent,
            eventText: hasEvent,
            hasTasks: hasTasks,
            tasksForDate: tasksForDate,
            completedTasks: completedTasks,
            pendingTasks: pendingTasks
        });
    }
    
    // Fill remaining cells to complete the grid (6 rows = 42 cells)
    const remainingCells = 42 - days.length;
    for (let i = 0; i < remainingCells; i++) {
        days.push({ day: '', isEmpty: true });
    }
    
    return days;
}

/**
 * Renders the calendar for the current month
 */
function renderCalendar() {
    const calendarDays = document.getElementById('calendarDays');
    const calendarTitle = document.getElementById('calendarTitle');
    
    if (!calendarDays || !calendarTitle) return;
    
    const year = currentCalendarDate.getFullYear();
    const month = currentCalendarDate.getMonth();
    
    // Update title
    const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ];
    calendarTitle.textContent = `${monthNames[month]} ${year}`;
    
    // Generate and render days
    const days = generateCalendarDays(year, month);
    calendarDays.innerHTML = '';
    
    days.forEach(dayObj => {
        const dayElement = document.createElement('div');
        
        if (dayObj.isEmpty) {
            dayElement.className = 'text-xs py-1 text-gray-600';
            dayElement.textContent = '';
        } else {
            let className = 'text-xs py-1 cursor-pointer hover:bg-gray-700 rounded transition-colors duration-200 relative';
            
            if (dayObj.isToday) {
                className += ' bg-blue-600 text-white font-medium';
            } else {
                className += ' text-gray-300';
            }
            
            // Add event indicator (legacy calendar events)
            if (dayObj.hasEvent) {
                className += ' after:content-[""] after:absolute after:bottom-1 after:right-1 after:w-1 after:h-1 after:bg-yellow-400 after:rounded-full';
            }
            
            // Add task indicator (new unified task system)
            if (dayObj.hasTasks) {
                // Show green dot for tasks, with different styling based on completion
                const taskIndicatorClass = dayObj.pendingTasks > 0 
                    ? 'after:bg-green-400' // Pending tasks
                    : 'after:bg-green-600'; // All completed
                
                className += ` after:content-[""] after:absolute after:bottom-1 after:left-1 after:w-1 after:h-1 after:rounded-full ${taskIndicatorClass}`;
            }
            
            dayElement.className = className;
            dayElement.textContent = dayObj.day;
            
            // Add click handler for task/event management
            dayElement.addEventListener('click', () => {
                if (dayObj.hasTasks) {
                    showTaskModal(dayObj.dateKey, dayObj.tasksForDate);
                } else if (dayObj.hasEvent) {
                    showEventModal(dayObj.dateKey, dayObj.eventText);
                } else {
                    showTaskModal(dayObj.dateKey, []);
                }
            });
            
            // Add tooltip for tasks and events
            let tooltipText = '';
            if (dayObj.hasTasks) {
                tooltipText += `${dayObj.tasksForDate.length} task(s)`;
                if (dayObj.pendingTasks > 0) {
                    tooltipText += ` (${dayObj.pendingTasks} pending)`;
                }
            }
            if (dayObj.hasEvent) {
                if (tooltipText) tooltipText += '\n';
                tooltipText += dayObj.eventText;
            }
            if (tooltipText) {
                dayElement.title = tooltipText;
            }
        }
        
        calendarDays.appendChild(dayElement);
    });
}

/**
 * Navigate to previous month
 */
function previousMonth() {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
    renderCalendar();
}

/**
 * Navigate to next month
 */
function nextMonth() {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
    renderCalendar();
}

// Initialize calendar functionality
document.getElementById('prevMonth')?.addEventListener('click', previousMonth);
document.getElementById('nextMonth')?.addEventListener('click', nextMonth);
loadCalendarEvents();
renderCalendar(); 