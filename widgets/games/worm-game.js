/**
 * ü§ñ AI-Generated Project: Minimalist Homepage
 * Generated by: Claude Sonnet 4 (Anthropic)
 * Date: 2024
 * Description: Worm Game Implementation - Classic snake-like game logic
 * Tech Stack: Vanilla HTML/CSS/JS + Tailwind CSS
 * License: MIT
 */

// ============================================================================
// WORM GAME IMPLEMENTATION
// ============================================================================

/**
 * Worm Game Class - A classic snake-like game
 */
class WormGame {
    constructor() {
        console.log('üéÆ Initializing Worm Game...');
        
        this.canvas = document.getElementById('wormCanvas');
        console.log('üéÆ Canvas element found:', !!this.canvas);
        
        if (!this.canvas) {
            console.error('‚ùå Worm canvas not found!');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        console.log('üéÆ Canvas context created:', !!this.ctx);
        
        // Game state
        this.gameState = {
            isRunning: false,
            isPaused: false,
            gameOver: false
        };
        
        // Worm properties
        this.worm = {
            body: [],
            direction: 'right',
            nextDirection: 'right'
        };
        
        // Food properties
        this.food = {
            x: 0,
            y: 0
        };
        
        // Game settings
        this.gridSize = 20; // 20x20 grid
        this.gameSpeed = 150; // milliseconds between moves
        this.score = 0;
        this.highScore = 0;
        
        // Animation frame
        this.gameLoop = null;
        this.lastMoveTime = 0;
        
        // Initialize the game
        this.init();
    }
    
    /**
     * Initialize the game
     */
    init() {
        this.setupCanvas();
        this.loadHighScore();
        this.setupEventListeners();
        this.resetGame();
        this.render();
    }
    
    /**
     * Setup canvas and responsive sizing
     */
    setupCanvas() {
        console.log('üé® Setting up canvas...');
        
        // Set canvas size
        this.canvas.width = 300;
        this.canvas.height = 300;
        
        console.log('üé® Canvas size set to:', this.canvas.width, 'x', this.canvas.height);
        
        // Calculate cell size
        this.cellSize = this.canvas.width / this.gridSize;
        
        console.log('üé® Cell size calculated:', this.cellSize, 'grid size:', this.gridSize);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.render();
        });
    }
    
    /**
     * Load high score from localStorage
     */
    loadHighScore() {
        const saved = localStorage.getItem('wormHighScore');
        this.highScore = saved ? parseInt(saved) : 0;
        this.updateScoreDisplay();
    }
    
    /**
     * Save high score to localStorage
     */
    saveHighScore() {
        localStorage.setItem('wormHighScore', this.highScore.toString());
    }
    
    /**
     * Setup event listeners for controls
     */
    setupEventListeners() {
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!this.gameState.isRunning) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    this.changeDirection('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    this.changeDirection('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    this.changeDirection('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    this.changeDirection('right');
                    break;
                case ' ':
                    e.preventDefault();
                    this.togglePause();
                    break;
            }
        });
        
        // D-pad controls
        const controlButtons = document.querySelectorAll('.dpad-btn');
        controlButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                e.preventDefault();
                const direction = button.getAttribute('data-direction');
                if (direction && this.gameState.isRunning) {
                    this.changeDirection(direction);
                }
            });
        });
        
        // Game control buttons
        document.getElementById('wormStart').addEventListener('click', () => {
            this.startGame();
        });
        
        document.getElementById('wormRestart').addEventListener('click', () => {
            this.resetGame();
        });
    }
    
    /**
     * Change worm direction (prevent 180-degree turns)
     */
    changeDirection(newDirection) {
        const opposites = {
            'up': 'down',
            'down': 'up',
            'left': 'right',
            'right': 'left'
        };
        
        // Prevent reverse direction
        if (opposites[newDirection] !== this.worm.direction) {
            this.worm.nextDirection = newDirection;
        }
    }
    
    /**
     * Start the game
     */
    startGame() {
        if (this.gameState.isRunning) return;
        
        this.gameState.isRunning = true;
        this.gameState.gameOver = false;
        this.gameState.isPaused = false;
        
        this.updateStatus('Game running - Use arrow keys or touch controls');
        this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
    }
    
    /**
     * Pause/unpause the game
     */
    togglePause() {
        if (!this.gameState.isRunning) return;
        
        this.gameState.isPaused = !this.gameState.isPaused;
        
        if (this.gameState.isPaused) {
            this.updateStatus('Game paused - Press space to resume');
        } else {
            this.updateStatus('Game running - Use arrow keys or touch controls');
            this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
        }
    }
    
    /**
     * Reset the game
     */
    resetGame() {
        console.log('üîÑ Resetting worm game...');
        
        // Stop current game loop
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
            this.gameLoop = null;
        }
        
        // Reset game state
        this.gameState.isRunning = false;
        this.gameState.isPaused = false;
        this.gameState.gameOver = false;
        
        // Reset worm
        this.worm.body = [
            { x: 10, y: 10 },
            { x: 9, y: 10 },
            { x: 8, y: 10 }
        ];
        this.worm.direction = 'right';
        this.worm.nextDirection = 'right';
        
        console.log('üêõ Worm body initialized:', this.worm.body);
        
        // Reset score
        this.score = 0;
        
        // Generate new food
        this.generateFood();
        
        console.log('üçé Food generated at:', this.food);
        
        // Update displays
        this.updateScoreDisplay();
        this.updateStatus('Press Start to begin');
        
        // Render initial state
        this.render();
    }
    
    /**
     * Generate food at random position
     */
    generateFood() {
        let newFood;
        do {
            newFood = {
                x: Math.floor(Math.random() * this.gridSize),
                y: Math.floor(Math.random() * this.gridSize)
            };
        } while (this.isPositionOccupied(newFood.x, newFood.y));
        
        this.food = newFood;
    }
    
    /**
     * Check if position is occupied by worm
     */
    isPositionOccupied(x, y) {
        return this.worm.body.some(segment => segment.x === x && segment.y === y);
    }
    
    /**
     * Main game update loop
     */
    update(timestamp) {
        if (!this.gameState.isRunning || this.gameState.isPaused) return;
        
        // Control game speed
        if (timestamp - this.lastMoveTime < this.gameSpeed) {
            this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
            return;
        }
        
        this.lastMoveTime = timestamp;
        
        // Update worm direction
        this.worm.direction = this.worm.nextDirection;
        
        // Move worm
        this.moveWorm();
        
        // Check collisions
        if (this.checkCollision()) {
            this.endGame();
            return;
        }
        
        // Check food collision
        this.checkFoodCollision();
        
        // Render
        this.render();
        
        // Continue game loop
        this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
    }
    
    /**
     * Move the worm
     */
    moveWorm() {
        const head = { ...this.worm.body[0] };
        
        // Move head based on direction
        switch (this.worm.direction) {
            case 'up':
                head.y = (head.y - 1 + this.gridSize) % this.gridSize;
                break;
            case 'down':
                head.y = (head.y + 1) % this.gridSize;
                break;
            case 'left':
                head.x = (head.x - 1 + this.gridSize) % this.gridSize;
                break;
            case 'right':
                head.x = (head.x + 1) % this.gridSize;
                break;
        }
        
        // Add new head
        this.worm.body.unshift(head);
        
        // Remove tail (unless food was eaten)
        if (!this.checkFoodCollision()) {
            this.worm.body.pop();
        }
    }
    
    /**
     * Check for collisions (walls or self)
     */
    checkCollision() {
        const head = this.worm.body[0];
        
        // Check self collision (starting from index 1 to skip head)
        for (let i = 1; i < this.worm.body.length; i++) {
            if (head.x === this.worm.body[i].x && head.y === this.worm.body[i].y) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if worm ate food
     */
    checkFoodCollision() {
        const head = this.worm.body[0];
        
        if (head.x === this.food.x && head.y === this.food.y) {
            // Increase score
            this.score++;
            if (this.score > this.highScore) {
                this.highScore = this.score;
                this.saveHighScore();
            }
            
            // Update display
            this.updateScoreDisplay();
            
            // Generate new food
            this.generateFood();
            
            // Increase speed slightly
            this.gameSpeed = Math.max(50, this.gameSpeed - 2);
            
            return true;
        }
        
        return false;
    }
    
    /**
     * End the game
     */
    endGame() {
        this.gameState.isRunning = false;
        this.gameState.gameOver = true;
        
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
            this.gameLoop = null;
        }
        
        this.updateStatus(`Game Over! Final Score: ${this.score}`);
    }
    
    /**
     * Render the game
     */
    render() {
        console.log('üîÑ Rendering worm game...');
        
        // Clear canvas
        this.ctx.fillStyle = '#1f2937'; // bg-gray-800
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        console.log('üé® Canvas cleared, drawing worm with', this.worm.body.length, 'segments');
        
        // Draw grid (optional - for debugging)
        this.drawGrid(); // Temporarily enable for debugging
        
        // Draw worm
        this.drawWorm();
        
        // Draw food
        this.drawFood();
        
        console.log('‚úÖ Worm game render complete');
    }
    
    /**
     * Draw the worm
     */
    drawWorm() {
        console.log('üêõ Drawing worm segments:', this.worm.body);
        
        this.ctx.fillStyle = '#10b981'; // text-green-500
        
        this.worm.body.forEach((segment, index) => {
            const x = segment.x * this.cellSize;
            const y = segment.y * this.cellSize;
            
            if (index === 0) {
                // Head - slightly larger and different color
                this.ctx.fillStyle = '#059669'; // text-green-600
                this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
                console.log('üêõ Drawing head at:', x, y, 'color:', this.ctx.fillStyle);
            } else {
                // Body
                this.ctx.fillStyle = '#10b981'; // text-green-500
                this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
                console.log('üêõ Drawing body segment at:', x, y, 'color:', this.ctx.fillStyle);
            }
        });
    }
    
    /**
     * Draw the food
     */
    drawFood() {
        const x = this.food.x * this.cellSize;
        const y = this.food.y * this.cellSize;
        
        console.log('üçé Drawing food at:', x, y, 'food position:', this.food);
        
        this.ctx.fillStyle = '#ef4444'; // text-red-500
        this.ctx.beginPath();
        this.ctx.arc(
            x + this.cellSize / 2, 
            y + this.cellSize / 2, 
            this.cellSize / 2 - 1, 
            0, 
            2 * Math.PI
        );
        this.ctx.fill();
        
        console.log('üçé Food drawn with color:', this.ctx.fillStyle);
    }
    
    /**
     * Draw grid (for debugging)
     */
    drawGrid() {
        this.ctx.strokeStyle = '#374151'; // border-gray-700
        this.ctx.lineWidth = 0.5;
        
        for (let i = 0; i <= this.gridSize; i++) {
            // Vertical lines
            this.ctx.beginPath();
            this.ctx.moveTo(i * this.cellSize, 0);
            this.ctx.lineTo(i * this.cellSize, this.canvas.height);
            this.ctx.stroke();
            
            // Horizontal lines
            this.ctx.beginPath();
            this.ctx.moveTo(0, i * this.cellSize);
            this.ctx.lineTo(this.canvas.width, i * this.cellSize);
            this.ctx.stroke();
        }
    }
    
    /**
     * Update score display
     */
    updateScoreDisplay() {
        const scoreElement = document.getElementById('wormScore');
        const highScoreElement = document.getElementById('wormHighScore');
        
        if (scoreElement) {
            scoreElement.textContent = `Score: ${this.score}`;
        }
        
        if (highScoreElement) {
            highScoreElement.textContent = `High Score: ${this.highScore}`;
        }
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        const statusElement = document.getElementById('wormStatus');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }
    
    /**
     * Clean up game resources
     */
    destroy() {
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
            this.gameLoop = null;
        }
        
        // Remove event listeners
        // Note: In a more sophisticated implementation, we'd store references to event listeners
        // and remove them properly. For now, we'll rely on the fact that the game manager
        // will handle the overall widget lifecycle.
    }
    
    /**
     * Static method to create a new worm game instance
     * @returns {WormGame} New worm game instance
     */
    static create() {
        return new WormGame();
    }
}

// Export the class for the game manager to use
window.WormGame = WormGame;

// Trigger the game manager to load the default game now that WormGame is available
if (typeof gameWidget !== 'undefined') {
    console.log('üéÆ WormGame class loaded, triggering default game load...');
    gameWidget.loadDefaultGame();
} else {
    console.warn('‚ö†Ô∏è Game widget manager not found, WormGame will be initialized manually');
    // Fallback: initialize worm game directly if game manager isn't available
    let wormGame = WormGame.create();
} 