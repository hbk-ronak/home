/**
 * ðŸ¤– AI-Generated Project: Minimalist Homepage
 * Generated by: Claude Sonnet 4 (Anthropic)
 * Date: 2024
 * Description: Clean, minimalist, dark-mode homepage with clock, search, music player, and to-do list
 * Tech Stack: Vanilla HTML/CSS/JS + Tailwind CSS
 * License: MIT
 */

// Minimalist Homepage - Main JavaScript

// ============================================================================
// CLOCK WIDGET (Ticket 2)
// ============================================================================

/**
 * Updates the clock display with current time
 */
function updateClock() {
    const clockElement = document.getElementById('clock');
    const now = new Date();
    const timeString = now.toLocaleTimeString('en-GB'); // 24-hour format
    clockElement.textContent = timeString;
}

// Initialize clock and update every second
updateClock();
setInterval(updateClock, 1000);

// ============================================================================
// SALUTATION MESSAGES (Ticket 12)
// ============================================================================

// Salutation messages array
const salutations = [
    'Good Morning',
    'Rise and Shine',
    'Hello there',
    'Welcome back',
    'Greetings',
    'Hey there',
    'Good to see you',
    'Hello friend',
    'Welcome',
    'Hi there'
];

/**
 * Gets a time-aware greeting based on current hour
 * @returns {string} Time-appropriate greeting
 */
function getTimeAwareGreeting() {
    const hour = new Date().getHours();
    if (hour < 12) return 'Good Morning';
    if (hour < 17) return 'Good Afternoon';
    return 'Good Evening';
}

/**
 * Sets a random salutation message
 */
function setRandomSalutation() {
    const salutationElement = document.getElementById('salutation');
    if (!salutationElement) return;
    
    // 70% chance for time-aware greeting, 30% for random salutation
    const useTimeAware = Math.random() < 0.7;
    
    let message;
    if (useTimeAware) {
        message = getTimeAwareGreeting();
    } else {
        message = salutations[Math.floor(Math.random() * salutations.length)];
    }
    
    salutationElement.textContent = message;
}

// Initialize salutation on page load
setRandomSalutation();

// ============================================================================
// SEARCH FUNCTIONALITY (Tickets 3, 9)
// ============================================================================

// Search engine configurations
const searchEngines = {
    google: "https://www.google.com/search?q=",
    duckduckgo: "https://duckduckgo.com/?q=",
    startpage: "https://www.startpage.com/sp/search?query="
};

// Search engine icons and names
const searchEngineData = {
    google: {
        name: 'Google',
        icon: `<svg class="w-5 h-5" viewBox="0 0 24 24">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
        </svg>`
    },
    duckduckgo: {
        name: 'DuckDuckGo',
        icon: `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="#DE5833">
            <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm0 2c5.514 0 10 4.486 10 10s-4.486 10-10 10S2 17.514 2 12 6.486 2 12 2zm0 3c-3.866 0-7 3.134-7 7s3.134 7 7 7 7-3.134 7-7-3.134-7-7-7zm0 2c2.761 0 5 2.239 5 5s-2.239 5-5 5-5-2.239-5-5 2.239-5 5-5z"/>
        </svg>`
    },
    startpage: {
        name: 'Startpage',
        icon: `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="#00A4DC">
            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
        </svg>`
    }
};

// Bang pattern for quick engine selection
const bangPattern = /^!(\w+)\s+(.*)$/;

// Bang to engine mapping
const bangEngines = {
    'g': 'google',
    'd': 'duckduckgo',
    's': 'startpage'
};

// Easter egg pattern and commands
const easterEggPattern = /^:(\w+)/;
const easterEggCommands = {
    'roll': () => Math.floor(Math.random() * 6) + 1,
    'flip': () => Math.random() < 0.5 ? 'Heads' : 'Tails',
    'ascii': () => 'ðŸ˜Š'
};

let currentSearchEngine = 'google';
let isDropdownOpen = false; // Track dropdown state globally

/**
 * Shows easter egg result in the output area
 * @param {string} result - The result to display
 */
function showEasterEggResult(result) {
    const outputArea = document.getElementById('easterEggOutput');
    const outputText = document.getElementById('easterEggResult');
    
    if (outputArea && outputText) {
        outputText.textContent = result;
        outputArea.classList.remove('hidden');
    } else {
        console.error('âŒ Easter egg output elements not found!');
    }
}

/**
 * Hides the easter egg output area
 */
function hideEasterEggResult() {
    const outputArea = document.getElementById('easterEggOutput');
    
    if (outputArea) {
        outputArea.classList.add('hidden');
    } else {
        console.error('âŒ Easter egg output element not found!');
    }
}

/**
 * Handles clicking outside the search engine dropdown to close it
 * @param {Event} event - Click event
 */
function handleClickOutsideDropdown(event) {
    const dropdown = document.getElementById('searchEngineDropdown');
    const toggle = document.getElementById('searchEngineToggle');
    
    if (dropdown && !dropdown.contains(event.target) && !toggle.contains(event.target)) {
        closeSearchEngineDropdown();
    }
}

/**
 * Updates the search engine display
 * @param {string} engine - Search engine key
 */
function updateSearchEngineDisplay(engine) {
    const iconElement = document.getElementById('searchEngineIcon');
    const nameElement = document.getElementById('searchEngineName');
    const inputElement = document.getElementById('searchInput');
    
    if (iconElement && nameElement && inputElement) {
        const engineData = searchEngineData[engine];
        iconElement.innerHTML = engineData.icon;
        nameElement.textContent = engineData.name;
        inputElement.placeholder = `Search with ${engineData.name} or enter address`;
        currentSearchEngine = engine;
    }
}

/**
 * Toggles the search engine dropdown
 */
function toggleSearchEngineDropdown() {
    try {
        isDropdownOpen = !isDropdownOpen;
        if (isDropdownOpen) {
            const dropdown = document.getElementById('searchEngineDropdown');
            if (dropdown) {
                dropdown.classList.remove('hidden');
            } else {
                console.error('Dropdown element not found');
                isDropdownOpen = false;
            }
        } else {
            const dropdown = document.getElementById('searchEngineDropdown');
            if (dropdown) {
                dropdown.classList.add('hidden');
            }
        }
    } catch (error) {
        console.error('Error toggling dropdown:', error);
        isDropdownOpen = false;
    }
}

/**
 * Closes the search engine dropdown
 */
function closeSearchEngineDropdown() {
    try {
        isDropdownOpen = false;
        const dropdown = document.getElementById('searchEngineDropdown');
        if (dropdown) {
            dropdown.classList.add('hidden');
        }
    } catch (error) {
        console.error('Error closing dropdown:', error);
    }
}

/**
 * Handles search engine selection from dropdown
 * @param {string} engine - Selected search engine
 */
function selectSearchEngine(engine) {
    updateSearchEngineDisplay(engine);
    localStorage.setItem('searchEngine', engine);
    closeSearchEngineDropdown();
}

/**
 * Handles search form submission with bang support
 * @param {Event} event - Form submit event
 */
function handleSearch(event) {
    event.preventDefault();
    
    const query = document.getElementById('searchInput').value.trim();
    
    if (!query) {
        alert('Please enter a search query');
        return;
    }
    
    // Check for easter egg commands first
    const easterEggMatch = query.match(easterEggPattern);
    if (easterEggMatch) {
        const command = easterEggMatch[1];
        if (easterEggCommands[command]) {
            const result = easterEggCommands[command]();
            showEasterEggResult(result);
            document.getElementById('searchInput').value = '';
            return;
        } else {
            alert(`Unknown command: ${command}`);
            return;
        }
    }
    
    // Check for bang commands (e.g., !g javascript, !d cats)
    const bangMatch = query.match(bangPattern);
    if (bangMatch) {
        const bangCommand = bangMatch[1].toLowerCase();
        const searchQuery = bangMatch[2].trim();
        
        if (bangEngines[bangCommand]) {
            const selectedEngine = bangEngines[bangCommand];
            updateSearchEngineDisplay(selectedEngine);
            localStorage.setItem('searchEngine', selectedEngine);
        } else {
            // Invalid bang command, use current engine
            alert(`Unknown search command: !${bangCommand}. Using current engine.`);
        }
        
        // Use the query without the bang command
        const searchUrl = searchEngines[currentSearchEngine] + encodeURIComponent(searchQuery);
        window.location.href = searchUrl;
        return;
    }
    
    // No bang command, use current engine
    const searchUrl = searchEngines[currentSearchEngine] + encodeURIComponent(query);
    window.location.href = searchUrl;
}

/**
 * Loads saved search engine preference
 */
function loadSearchPreference() {
    const savedEngine = localStorage.getItem('searchEngine');
    if (savedEngine) {
        updateSearchEngineDisplay(savedEngine);
    } else {
        updateSearchEngineDisplay('google');
    }
}

// Initialize search functionality
document.getElementById('searchForm').addEventListener('submit', handleSearch);
document.getElementById('searchEngineToggle').addEventListener('click', toggleSearchEngineDropdown);

// Add event listeners for search engine options
document.querySelectorAll('.search-engine-option').forEach(option => {
    option.addEventListener('click', () => {
        selectSearchEngine(option.dataset.engine);
    });
});

// Close dropdown when clicking outside
document.addEventListener('click', handleClickOutsideDropdown);

loadSearchPreference();

// Initialize dropdown state on page load
isDropdownOpen = false;

// Focus search input on page load
document.addEventListener('DOMContentLoaded', () => {
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.focus();
    }
});

// ============================================================================
// YOUTUBE MUSIC PLAYER (Ticket 4)
// ============================================================================

/**
 * Handles YouTube Music playlist button click
 * Note: Replace PLAYLIST_ID with actual playlist ID
 */
function handleMusicPlay() {
    const playlistId = 'RDCLAK5uy_nFD4lodGvr1kb0xlJOOfEi0tGWI7cQKK0'; // TODO: Replace with actual playlist ID
    const musicUrl = `https://music.youtube.com/playlist?list=${playlistId}&play=1`;
    window.open(musicUrl, '_blank');
}

// Initialize YouTube Music functionality
document.getElementById('playMusicBtn').addEventListener('click', handleMusicPlay);

// ============================================================================
// TO-DO LIST FUNCTIONALITY (Tickets 5, 6) - REFACTORED FOR UNIFIED TASK STORE
// ============================================================================

let currentTodoFilter = 'all';

/**
 * Renders all todo tasks to the DOM based on current filter
 */
function renderTodos() {
    const todoList = document.getElementById('todoList');
    if (!todoList) return;
    
    todoList.innerHTML = '';
    
    let tasks = [];
    switch (currentTodoFilter) {
        case 'dated':
            tasks = window.taskStore.getDatedTasks();
            break;
        case 'undated':
            tasks = window.taskStore.getUndatedTasks();
            break;
        case 'today':
            tasks = window.taskStore.getTasksForToday();
            break;
        default:
            tasks = window.taskStore.getTasks();
            break;
    }
    
    tasks.forEach(task => {
        const taskElement = createTodoElement(task);
        todoList.appendChild(taskElement);
    });
}

/**
 * Handles todo filter change
 * @param {Event} event - Change event
 */
function handleTodoFilterChange(event) {
    currentTodoFilter = event.target.value;
    renderTodos();
}

/**
 * Loads todo filter preference from localStorage
 */
function loadTodoFilterPreference() {
    const savedFilter = localStorage.getItem('todoFilter');
    if (savedFilter) {
        currentTodoFilter = savedFilter;
        const filterSelect = document.getElementById('todoFilter');
        if (filterSelect) {
            filterSelect.value = currentTodoFilter;
        }
    }
}

/**
 * Saves todo filter preference to localStorage
 */
function saveTodoFilterPreference() {
    localStorage.setItem('todoFilter', currentTodoFilter);
}

/**
 * Creates a DOM element for a todo task
 * @param {Object} task - Task object with id, text, completed, and dueDate properties
 * @returns {HTMLElement} Task element
 */
function createTodoElement(task) {
    const taskDiv = document.createElement('div');
    taskDiv.className = 'flex items-center gap-3 p-2 bg-gray-800 rounded-lg';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'todo-checkbox';
    checkbox.checked = task.completed;
    checkbox.addEventListener('change', () => toggleTodo(task.id));
    
    const textSpan = document.createElement('span');
    textSpan.className = `flex-1 ${task.completed ? 'line-through text-gray-500' : 'text-gray-200'}`;
    textSpan.textContent = task.text;
    
    // Add due date display if present
    if (task.dueDate) {
        const dueDateSpan = document.createElement('span');
        dueDateSpan.className = `text-xs ${task.completed ? 'text-gray-500' : 'text-blue-400'}`;
        dueDateSpan.textContent = ` (${formatDate(task.dueDate)})`;
        textSpan.appendChild(dueDateSpan);
    }
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'text-red-400 hover:text-red-300 transition-colors duration-200';
    deleteBtn.innerHTML = `
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>
    `;
    deleteBtn.addEventListener('click', () => deleteTodo(task.id));
    
    taskDiv.appendChild(checkbox);
    taskDiv.appendChild(textSpan);
    taskDiv.appendChild(deleteBtn);
    
    return taskDiv;
}

/**
 * Adds a new todo task
 * @param {string} text - Task text
 * @param {string|null} dueDate - Due date in 'YYYY-MM-DD' format (optional)
 */
function addTodo(text, dueDate = null) {
    if (!text.trim()) {
        alert('Please enter a task');
        return;
    }
    
    const taskData = {
        text: text.trim(),
        dueDate: dueDate
    };
    
    window.taskStore.addTask(taskData);
    renderTodos();
    renderCalendar(); // Update calendar to show new task
}

/**
 * Toggles the completion status of a todo task
 * @param {string} taskId - Task ID to toggle
 */
function toggleTodo(taskId) {
    window.taskStore.toggleTask(taskId);
    renderTodos();
    renderCalendar(); // Update calendar to reflect completion
}

/**
 * Deletes a todo task
 * @param {string} taskId - Task ID to delete
 */
function deleteTodo(taskId) {
    window.taskStore.deleteTask(taskId);
    renderTodos();
    renderCalendar(); // Update calendar to remove task
}

/**
 * Handles todo form submission
 * @param {Event} event - Form submit event
 */
function handleTodoSubmit(event) {
    event.preventDefault();
    
    const input = document.getElementById('todoInput');
    const dateInput = document.getElementById('todoDueDate');
    const text = input.value;
    const dueDate = dateInput.value || null;
    
    addTodo(text, dueDate);
    input.value = '';
    dateInput.value = '';
    input.focus();
}

/**
 * Formats a date string for display
 * @param {string} dateStr - Date in 'YYYY-MM-DD' format
 * @returns {string} Formatted date string
 */
function formatDate(dateStr) {
    // Parse the date string properly to avoid timezone issues
    const [year, month, day] = dateStr.split('-').map(Number);
    const date = new Date(year, month - 1, day); // month is 0-indexed in Date constructor
    
    return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric' 
    });
}

// Initialize todo functionality
document.getElementById('todoForm').addEventListener('submit', handleTodoSubmit);
document.getElementById('todoFilter').addEventListener('change', handleTodoFilterChange);
loadTodoFilterPreference();

// ============================================================================
// STICKY NOTES FUNCTIONALITY (Ticket 11)
// ============================================================================

let stickyNotes = [];

// Color options for sticky notes
const noteColors = [
    { name: 'yellow', class: 'bg-yellow-200 text-yellow-900' },
    { name: 'pink', class: 'bg-pink-200 text-pink-900' },
    { name: 'blue', class: 'bg-blue-200 text-blue-900' },
    { name: 'green', class: 'bg-green-200 text-green-900' }
];

/**
 * Generates a unique ID for sticky notes
 * @returns {string} Unique ID
 */
function generateNoteId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

/**
 * Saves sticky notes to localStorage
 */
function saveNotes() {
    localStorage.setItem('stickyNotes', JSON.stringify(stickyNotes));
}

/**
 * Loads sticky notes from localStorage
 */
function loadNotes() {
    const saved = localStorage.getItem('stickyNotes');
    if (saved) {
        stickyNotes = JSON.parse(saved);
        renderNotes();
    }
}

/**
 * Renders all sticky notes to the DOM
 */
function renderNotes() {
    const notesGrid = document.getElementById('notesGrid');
    notesGrid.innerHTML = '';
    
    stickyNotes.forEach(note => {
        const noteElement = createNoteElement(note);
        notesGrid.appendChild(noteElement);
    });
}

/**
 * Creates a DOM element for a sticky note
 * @param {Object} note - Note object with id, text, color, and createdAt properties
 * @returns {HTMLElement} Note element
 */
function createNoteElement(note) {
    const noteDiv = document.createElement('div');
    const colorClass = noteColors.find(c => c.name === note.color)?.class || noteColors[0].class;
    
    noteDiv.className = `p-3 rounded-lg shadow-md relative group ${colorClass}`;
    noteDiv.innerHTML = `
        <div class="text-sm font-medium mb-2">${note.text}</div>
        <button class="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-gray-600 hover:text-gray-800">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        </button>
    `;
    
    // Add delete functionality
    const deleteBtn = noteDiv.querySelector('button');
    deleteBtn.addEventListener('click', () => deleteNote(note.id));
    
    return noteDiv;
}

/**
 * Adds a new sticky note
 * @param {string} text - Note text
 * @param {string} color - Note color
 */
function addNote(text, color) {
    if (!text.trim()) {
        alert('Please enter a note');
        return;
    }
    
    const newNote = {
        id: generateNoteId(),
        text: text.trim(),
        color: color,
        createdAt: Date.now()
    };
    
    stickyNotes.push(newNote);
    saveNotes();
    renderNotes();
}

/**
 * Deletes a sticky note
 * @param {string} noteId - Note ID to delete
 */
function deleteNote(noteId) {
    stickyNotes = stickyNotes.filter(n => n.id !== noteId);
    saveNotes();
    renderNotes();
}

/**
 * Handles note form submission
 * @param {Event} event - Form submit event
 */
function handleNoteSubmit(event) {
    event.preventDefault();
    
    const input = document.getElementById('noteInput');
    const colorSelect = document.getElementById('noteColor');
    const text = input.value;
    const color = colorSelect.value;
    
    addNote(text, color);
    input.value = '';
    input.focus();
}

// Initialize sticky notes functionality
document.getElementById('noteForm').addEventListener('submit', handleNoteSubmit);
loadNotes();

// ============================================================================
// MINI CALENDAR WIDGET (Ticket 10)
// ============================================================================

let currentCalendarDate = new Date();

// Calendar events data
let calendarEvents = {};

/**
 * Gets the number of days in a month
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @returns {number} Number of days in the month
 */
function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}

/**
 * Gets the day of week for the first day of a month
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @returns {number} Day of week (0-6, where 0 is Sunday)
 */
function getFirstDayOfMonth(year, month) {
    return new Date(year, month, 1).getDay();
}

/**
 * Gets a date key for localStorage storage
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @param {number} day - Day of month
 * @returns {string} Date key in YYYY-MM-DD format
 */
function getDateKey(year, month, day) {
    return new Date(year, month, day).toISOString().split('T')[0];
}

/**
 * Loads calendar events from localStorage
 */
function loadCalendarEvents() {
    const saved = localStorage.getItem('calendarEvents');
    if (saved) {
        calendarEvents = JSON.parse(saved);
    }
}

/**
 * Saves calendar events to localStorage
 */
function saveCalendarEvents() {
    localStorage.setItem('calendarEvents', JSON.stringify(calendarEvents));
}

/**
 * Adds an event to a specific date
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 * @param {string} eventText - Event description
 */
function addCalendarEvent(dateKey, eventText) {
    if (eventText.trim()) {
        calendarEvents[dateKey] = eventText.trim();
        saveCalendarEvents();
    }
}

/**
 * Removes an event from a specific date
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 */
function removeCalendarEvent(dateKey) {
    delete calendarEvents[dateKey];
    saveCalendarEvents();
}

/**
 * Shows event input modal
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 * @param {string} currentEvent - Current event text (if editing)
 */
function showEventModal(dateKey, currentEvent = '') {
    const eventText = prompt(
        currentEvent ? 'Edit event:' : 'Add event for this date:',
        currentEvent
    );
    
    if (eventText !== null) {
        if (eventText.trim()) {
            addCalendarEvent(dateKey, eventText);
        } else if (currentEvent) {
            removeCalendarEvent(dateKey);
        }
        renderCalendar();
    }
}

/**
 * Shows task input modal
 * @param {string} dateKey - Date key in YYYY-MM-DD format
 * @param {Array} tasksForDate - Array of task objects for this date
 */
function showTaskModal(dateKey, tasksForDate) {
    const taskText = prompt(
        tasksForDate.length > 0 ? 'Edit tasks for this date:' : 'Add tasks for this date:',
        tasksForDate.map(task => `${task.text} (Completed: ${task.completed ? 'Yes' : 'No'})`).join('\n')
    );

    if (taskText !== null) {
        const newTasks = taskText.split('\n').map(line => {
            const parts = line.trim().split(' ');
            const text = parts.slice(0, -1).join(' '); // Get text before completion status
            const completed = parts.slice(-1)[0] === 'Completed: Yes';
            return { text: text, completed: completed };
        });

        // Filter out empty lines and invalid lines
        const validTasks = newTasks.filter(task => task.text.trim() !== '');

        if (validTasks.length > 0) {
            window.taskStore.addTasksForDate(dateKey, validTasks);
            renderTodos(); // Re-render todos to show new tasks
            renderCalendar(); // Re-render calendar to show task indicators
        } else if (tasksForDate.length > 0) {
            // If user cancelled and there were tasks, remove them
            window.taskStore.deleteTasksForDate(dateKey);
            renderTodos();
            renderCalendar();
        }
    }
}

/**
 * Generates calendar days for a given month
 * @param {number} year - Year
 * @param {number} month - Month (0-11)
 * @returns {Array} Array of day objects
 */
function generateCalendarDays(year, month) {
    const daysInMonth = getDaysInMonth(year, month);
    const firstDayOfMonth = getFirstDayOfMonth(year, month);
    const days = [];
    
    // Add empty cells for days before the first day of the month
    for (let i = 0; i < firstDayOfMonth; i++) {
        days.push({ day: '', isEmpty: true });
    }
    
    // Add days of the month
    for (let day = 1; day <= daysInMonth; day++) {
        const dateKey = getDateKey(year, month, day);
        const isToday = new Date().toDateString() === new Date(year, month, day).toDateString();
        const hasEvent = calendarEvents[dateKey];
        
        // Check for tasks on this date using task store
        const tasksForDate = window.taskStore.getTasksByDate(dateKey);
        const hasTasks = tasksForDate.length > 0;
        const completedTasks = tasksForDate.filter(task => task.completed).length;
        const pendingTasks = tasksForDate.length - completedTasks;
        
        days.push({ 
            day: day, 
            isEmpty: false, 
            isToday: isToday,
            isCurrentMonth: true,
            dateKey: dateKey,
            hasEvent: hasEvent,
            eventText: hasEvent,
            hasTasks: hasTasks,
            tasksForDate: tasksForDate,
            completedTasks: completedTasks,
            pendingTasks: pendingTasks
        });
    }
    
    // Fill remaining cells to complete the grid (6 rows = 42 cells)
    const remainingCells = 42 - days.length;
    for (let i = 0; i < remainingCells; i++) {
        days.push({ day: '', isEmpty: true });
    }
    
    return days;
}

/**
 * Renders the calendar for the current month
 */
function renderCalendar() {
    const calendarDays = document.getElementById('calendarDays');
    const calendarTitle = document.getElementById('calendarTitle');
    
    if (!calendarDays || !calendarTitle) return;
    
    const year = currentCalendarDate.getFullYear();
    const month = currentCalendarDate.getMonth();
    
    // Update title
    const monthNames = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ];
    calendarTitle.textContent = `${monthNames[month]} ${year}`;
    
    // Generate and render days
    const days = generateCalendarDays(year, month);
    calendarDays.innerHTML = '';
    
    days.forEach(dayObj => {
        const dayElement = document.createElement('div');
        
        if (dayObj.isEmpty) {
            dayElement.className = 'text-xs py-1 text-gray-600';
            dayElement.textContent = '';
        } else {
            let className = 'text-xs py-1 cursor-pointer hover:bg-gray-700 rounded transition-colors duration-200 relative';
            
            if (dayObj.isToday) {
                className += ' bg-blue-600 text-white font-medium';
            } else {
                className += ' text-gray-300';
            }
            
            // Add event indicator (legacy calendar events)
            if (dayObj.hasEvent) {
                className += ' after:content-[""] after:absolute after:bottom-1 after:right-1 after:w-1 after:h-1 after:bg-yellow-400 after:rounded-full';
            }
            
            // Add task indicator (new unified task system)
            if (dayObj.hasTasks) {
                // Show green dot for tasks, with different styling based on completion
                const taskIndicatorClass = dayObj.pendingTasks > 0 
                    ? 'after:bg-green-400' // Pending tasks
                    : 'after:bg-green-600'; // All completed
                
                className += ` after:content-[""] after:absolute after:bottom-1 after:left-1 after:w-1 after:h-1 after:rounded-full ${taskIndicatorClass}`;
            }
            
            dayElement.className = className;
            dayElement.textContent = dayObj.day;
            
            // Add click handler for task/event management
            dayElement.addEventListener('click', () => {
                if (dayObj.hasTasks) {
                    showTaskModal(dayObj.dateKey, dayObj.tasksForDate);
                } else if (dayObj.hasEvent) {
                    showEventModal(dayObj.dateKey, dayObj.eventText);
                } else {
                    showTaskModal(dayObj.dateKey, []);
                }
            });
            
            // Add tooltip for tasks and events
            let tooltipText = '';
            if (dayObj.hasTasks) {
                tooltipText += `${dayObj.tasksForDate.length} task(s)`;
                if (dayObj.pendingTasks > 0) {
                    tooltipText += ` (${dayObj.pendingTasks} pending)`;
                }
            }
            if (dayObj.hasEvent) {
                if (tooltipText) tooltipText += '\n';
                tooltipText += dayObj.eventText;
            }
            if (tooltipText) {
                dayElement.title = tooltipText;
            }
        }
        
        calendarDays.appendChild(dayElement);
    });
}

/**
 * Navigate to previous month
 */
function previousMonth() {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
    renderCalendar();
}

/**
 * Navigate to next month
 */
function nextMonth() {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
    renderCalendar();
}

// Initialize calendar functionality
document.getElementById('prevMonth')?.addEventListener('click', previousMonth);
document.getElementById('nextMonth')?.addEventListener('click', nextMonth);
loadCalendarEvents();
renderCalendar();

// Initialize todo functionality with task store
renderTodos();

// ============================================================================
// DATA MANAGEMENT (Ticket 2)
// ============================================================================

/**
 * Clears all data from localStorage
 */
function clearAllData() {
    const confirmed = confirm(
        'Are you sure you want to clear all data?\n\n' +
        'This will remove:\n' +
        'â€¢ All to-do tasks\n' +
        'â€¢ All sticky notes\n' +
        'â€¢ All calendar events\n' +
        'â€¢ Search engine preferences\n\n' +
        'This action cannot be undone.'
    );
    
    if (confirmed) {
        localStorage.clear();
        location.reload();
    }
}

// Initialize data management functionality
document.getElementById('clearAllDataBtn')?.addEventListener('click', clearAllData);

// Initialize easter egg functionality
document.getElementById('easterEggClose')?.addEventListener('click', (event) => {
    event.preventDefault();
    event.stopPropagation();
    hideEasterEggResult();
});

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Shows a simple alert message (can be enhanced with a proper toast notification)
 * @param {string} message - Message to display
 */
function showMessage(message) {
    alert(message); // TODO: Replace with proper toast notification
}

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize all components when DOM is loaded
 */
function initializeApp() {
    // All initialization is handled by individual component functions above
    // This function can be used for any app-wide initialization in the future
}

// Run initialization when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

// ============================================================================
// DEBUG FUNCTIONS
// ============================================================================

/**
 * Test function to check dropdown functionality (for debugging)
 */
function testDropdownFunctionality() {
    const dropdown = document.getElementById('searchEngineDropdown');
    const toggle = document.getElementById('searchEngineToggle');
    const easterEggOutput = document.getElementById('easterEggOutput');
    
    console.log('ðŸ§ª TEST: Checking dropdown functionality...');
    console.log('ðŸ§ª Dropdown element:', !!dropdown);
    console.log('ðŸ§ª Toggle element:', !!toggle);
    console.log('ðŸ§ª Easter egg output:', !!easterEggOutput);
    
    if (dropdown) {
        console.log('ðŸ§ª Dropdown classes:', dropdown.className);
        console.log('ðŸ§ª Dropdown hidden:', dropdown.classList.contains('hidden'));
    }
    
    if (easterEggOutput) {
        console.log('ðŸ§ª Easter egg classes:', easterEggOutput.className);
        console.log('ðŸ§ª Easter egg hidden:', easterEggOutput.classList.contains('hidden'));
    }
    
    console.log('ðŸ§ª isDropdownOpen state:', isDropdownOpen);
}

/**
 * Force reset all UI elements to correct state (for debugging)
 */
function forceResetUI() {
    // Force close dropdown
    const dropdown = document.getElementById('searchEngineDropdown');
    if (dropdown) {
        dropdown.classList.add('hidden');
        isDropdownOpen = false;
    }
    
    // Force hide easter egg output
    const easterEggOutput = document.getElementById('easterEggOutput');
    if (easterEggOutput) {
        easterEggOutput.classList.add('hidden');
    }
    
    // Clear search input
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.value = '';
        searchInput.focus();
    }
}

// Make test functions globally available
window.testDropdownFunctionality = testDropdownFunctionality;
window.forceResetUI = forceResetUI;

// ============================================================================
// CALCULATOR WIDGET (Ticket 13)
// ============================================================================

/**
 * Calculator class for handling all calculator operations
 */
class Calculator {
    constructor() {
        this.displayValue = '0';
        this.previousValue = null;
        this.operation = null;
        this.waitingForOperand = false;
        this.previousCalculation = '';
        
        this.displayElement = document.getElementById('calcDisplay');
        this.previousElement = document.getElementById('calcPrevious');
        
        this.initializeEventListeners();
    }
    
    /**
     * Initialize event listeners for calculator buttons and keyboard
     */
    initializeEventListeners() {
        // Button click events
        document.querySelectorAll('.calc-btn').forEach(button => {
            button.addEventListener('click', (e) => this.handleButtonClick(e));
        });
        
        // Keyboard events (with proper scoping)
        document.addEventListener('keydown', (e) => this.handleKeyboardInput(e));
    }
    
    /**
     * Handle button click events
     */
    handleButtonClick(event) {
        const button = event.currentTarget;
        const type = button.dataset.type;
        const value = button.dataset.value;
        
        this.processInput(type, value);
        this.updateDisplay();
    }
    
    /**
     * Handle keyboard input with proper scoping
     */
    handleKeyboardInput(event) {
        // Only handle calculator keys when no other input is active
        if (document.activeElement.tagName === 'INPUT') return;
        
        const key = event.key;
        const keyMap = {
            '0': { type: 'digit', value: '0' },
            '1': { type: 'digit', value: '1' },
            '2': { type: 'digit', value: '2' },
            '3': { type: 'digit', value: '3' },
            '4': { type: 'digit', value: '4' },
            '5': { type: 'digit', value: '5' },
            '6': { type: 'digit', value: '6' },
            '7': { type: 'digit', value: '7' },
            '8': { type: 'digit', value: '8' },
            '9': { type: 'digit', value: '9' },
            '.': { type: 'decimal', value: '.' },
            '+': { type: 'operation', value: '+' },
            '-': { type: 'operation', value: '-' },
            '*': { type: 'operation', value: 'Ã—' },
            '/': { type: 'operation', value: 'Ã·' },
            'Enter': { type: 'equals', value: '=' },
            '=': { type: 'equals', value: '=' },
            'Escape': { type: 'clear', value: 'C' }
        };
        
        if (keyMap[key]) {
            event.preventDefault();
            this.processInput(keyMap[key].type, keyMap[key].value);
            this.updateDisplay();
        }
    }
    
    /**
     * Process input based on type and value
     */
    processInput(type, value) {
        switch (type) {
            case 'digit':
                this.inputDigit(value);
                break;
            case 'decimal':
                this.inputDecimal();
                break;
            case 'operation':
                this.performOperation(value);
                break;
            case 'clear':
                this.clear(value === 'CE' ? 'entry' : 'all');
                break;
            case 'equals':
                this.calculate();
                break;
        }
    }
    
    /**
     * Handle digit input
     */
    inputDigit(digit) {
        if (this.waitingForOperand) {
            this.displayValue = digit;
            this.waitingForOperand = false;
        } else {
            this.displayValue = this.displayValue === '0' ? digit : this.displayValue + digit;
        }
    }
    
    /**
     * Handle decimal point input
     */
    inputDecimal() {
        if (this.waitingForOperand) {
            this.displayValue = '0.';
            this.waitingForOperand = false;
            return;
        }
        
        if (!this.displayValue.includes('.')) {
            this.displayValue += '.';
        }
    }
    
    /**
     * Perform mathematical operation
     */
    performOperation(nextOperation) {
        const inputValue = parseFloat(this.displayValue);
        
        if (this.previousValue === null) {
            this.previousValue = inputValue;
        } else if (this.operation) {
            const result = this.calculate(this.previousValue, inputValue, this.operation);
            this.displayValue = String(result);
            this.previousValue = result;
        }
        
        this.waitingForOperand = true;
        this.operation = nextOperation;
        this.updatePreviousCalculation();
    }
    
    /**
     * Perform calculation between two values
     */
    calculate(firstValue = null, secondValue = null, operation = null) {
        const inputValue = parseFloat(this.displayValue);
        
        if (firstValue === null) {
            // Final calculation (equals button)
            if (this.previousValue === null || this.operation === null) {
                return inputValue;
            }
            
            const result = this.calculate(this.previousValue, inputValue, this.operation);
            this.displayValue = String(result);
            this.previousValue = null;
            this.operation = null;
            this.waitingForOperand = true;
            this.previousCalculation = '';
            return result;
        } else {
            // Intermediate calculation
            switch (operation) {
                case '+':
                    return firstValue + secondValue;
                case '-':
                    return firstValue - secondValue;
                case 'Ã—':
                    return firstValue * secondValue;
                case 'Ã·':
                    if (secondValue === 0) {
                        this.displayValue = 'Error';
                        this.previousValue = null;
                        this.operation = null;
                        this.waitingForOperand = true;
                        return 'Error';
                    }
                    return firstValue / secondValue;
                case '%':
                    return firstValue % secondValue;
                case 'âˆš':
                    if (secondValue < 0) {
                        this.displayValue = 'Error';
                        this.previousValue = null;
                        this.operation = null;
                        this.waitingForOperand = true;
                        return 'Error';
                    }
                    return Math.sqrt(secondValue);
                case 'xÂ²':
                    return Math.pow(secondValue, 2);
                default:
                    return secondValue;
            }
        }
    }
    
    /**
     * Clear calculator state
     */
    clear(type = 'all') {
        if (type === 'all') {
            this.displayValue = '0';
            this.previousValue = null;
            this.operation = null;
            this.waitingForOperand = false;
            this.previousCalculation = '';
        } else {
            // Clear entry only
            this.displayValue = '0';
            this.waitingForOperand = false;
        }
    }
    
    /**
     * Update the previous calculation display
     */
    updatePreviousCalculation() {
        if (this.previousValue !== null && this.operation) {
            this.previousCalculation = `${this.previousValue} ${this.operation}`;
        }
    }
    
    /**
     * Update the calculator display
     */
    updateDisplay() {
        if (this.displayElement) {
            this.displayElement.textContent = this.displayValue;
        }
        
        if (this.previousElement) {
            this.previousElement.textContent = this.previousCalculation;
        }
    }
}

// Initialize calculator when DOM is loaded
let calculator;
document.addEventListener('DOMContentLoaded', () => {
    calculator = new Calculator();
});

// ============================================================================
// END OF CALCULATOR WIDGET
// ============================================================================

// ============================================================================
// WORM GAME WIDGET
// ============================================================================

/**
 * Worm Game Class - A classic snake-like game
 */
class WormGame {
    constructor() {
        this.canvas = document.getElementById('wormCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game state
        this.gameState = {
            isRunning: false,
            isPaused: false,
            gameOver: false
        };
        
        // Worm properties
        this.worm = {
            body: [],
            direction: 'right',
            nextDirection: 'right'
        };
        
        // Food properties
        this.food = {
            x: 0,
            y: 0
        };
        
        // Game settings
        this.gridSize = 20; // 20x20 grid
        this.gameSpeed = 150; // milliseconds between moves
        this.score = 0;
        this.highScore = 0;
        
        // Animation frame
        this.gameLoop = null;
        this.lastMoveTime = 0;
        
        // Initialize the game
        this.init();
    }
    
    /**
     * Initialize the game
     */
    init() {
        this.setupCanvas();
        this.loadHighScore();
        this.setupEventListeners();
        this.resetGame();
        this.render();
    }
    
    /**
     * Setup canvas and responsive sizing
     */
    setupCanvas() {
        // Set canvas size
        this.canvas.width = 300;
        this.canvas.height = 300;
        
        // Calculate cell size
        this.cellSize = this.canvas.width / this.gridSize;
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.render();
        });
    }
    
    /**
     * Load high score from localStorage
     */
    loadHighScore() {
        const saved = localStorage.getItem('wormHighScore');
        this.highScore = saved ? parseInt(saved) : 0;
        this.updateScoreDisplay();
    }
    
    /**
     * Save high score to localStorage
     */
    saveHighScore() {
        localStorage.setItem('wormHighScore', this.highScore.toString());
    }
    
    /**
     * Setup event listeners for controls
     */
    setupEventListeners() {
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!this.gameState.isRunning) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    this.changeDirection('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    this.changeDirection('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    this.changeDirection('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    this.changeDirection('right');
                    break;
                case ' ':
                    e.preventDefault();
                    this.togglePause();
                    break;
            }
        });
        
        // D-pad controls
        const controlButtons = document.querySelectorAll('.dpad-btn');
        controlButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                e.preventDefault();
                const direction = button.getAttribute('data-direction');
                if (direction && this.gameState.isRunning) {
                    this.changeDirection(direction);
                }
            });
        });
        
        // Game control buttons
        document.getElementById('wormStart').addEventListener('click', () => {
            this.startGame();
        });
        
        document.getElementById('wormRestart').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Game selector dropdown
        this.setupGameSelector();
    }
    
    /**
     * Setup game selector dropdown functionality
     */
    setupGameSelector() {
        const toggle = document.getElementById('gameSelectorToggle');
        const dropdown = document.getElementById('gameSelectorDropdown');
        const gameOptions = document.querySelectorAll('.game-option');
        
        if (toggle && dropdown) {
            // Toggle dropdown
            toggle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropdown.classList.toggle('hidden');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!toggle.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.add('hidden');
                }
            });
            
            // Handle game selection
            gameOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    e.preventDefault();
                    const game = option.getAttribute('data-game');
                    if (game && !option.disabled) {
                        this.selectGame(game);
                        dropdown.classList.add('hidden');
                    }
                });
            });
        }
    }
    
    /**
     * Select a different game (placeholder for future games)
     * @param {string} game - Game identifier
     */
    selectGame(game) {
        const currentGameName = document.getElementById('currentGameName');
        
        switch (game) {
            case 'worm':
                if (currentGameName) {
                    currentGameName.textContent = 'Worm Game';
                }
                // Worm game is already loaded
                break;
            case 'tictactoe':
                if (currentGameName) {
                    currentGameName.textContent = 'Tic-Tac-Toe';
                }
                // TODO: Implement Tic-Tac-Toe game
                alert('Tic-Tac-Toe coming soon!');
                break;
            default:
                console.warn('Unknown game:', game);
        }
    }
    
    /**
     * Change worm direction (prevent 180-degree turns)
     */
    changeDirection(newDirection) {
        const opposites = {
            'up': 'down',
            'down': 'up',
            'left': 'right',
            'right': 'left'
        };
        
        // Prevent reverse direction
        if (opposites[newDirection] !== this.worm.direction) {
            this.worm.nextDirection = newDirection;
        }
    }
    
    /**
     * Start the game
     */
    startGame() {
        if (this.gameState.isRunning) return;
        
        this.gameState.isRunning = true;
        this.gameState.gameOver = false;
        this.gameState.isPaused = false;
        
        this.updateStatus('Game running - Use arrow keys or touch controls');
        this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
    }
    
    /**
     * Pause/unpause the game
     */
    togglePause() {
        if (!this.gameState.isRunning) return;
        
        this.gameState.isPaused = !this.gameState.isPaused;
        
        if (this.gameState.isPaused) {
            this.updateStatus('Game paused - Press space to resume');
        } else {
            this.updateStatus('Game running - Use arrow keys or touch controls');
            this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
        }
    }
    
    /**
     * Reset the game
     */
    resetGame() {
        // Stop current game loop
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
            this.gameLoop = null;
        }
        
        // Reset game state
        this.gameState.isRunning = false;
        this.gameState.isPaused = false;
        this.gameState.gameOver = false;
        
        // Reset worm
        this.worm.body = [
            { x: 10, y: 10 },
            { x: 9, y: 10 },
            { x: 8, y: 10 }
        ];
        this.worm.direction = 'right';
        this.worm.nextDirection = 'right';
        
        // Reset score
        this.score = 0;
        
        // Generate new food
        this.generateFood();
        
        // Update displays
        this.updateScoreDisplay();
        this.updateStatus('Press Start to begin');
        
        // Render initial state
        this.render();
    }
    
    /**
     * Generate food at random position
     */
    generateFood() {
        let newFood;
        do {
            newFood = {
                x: Math.floor(Math.random() * this.gridSize),
                y: Math.floor(Math.random() * this.gridSize)
            };
        } while (this.isPositionOccupied(newFood.x, newFood.y));
        
        this.food = newFood;
    }
    
    /**
     * Check if position is occupied by worm
     */
    isPositionOccupied(x, y) {
        return this.worm.body.some(segment => segment.x === x && segment.y === y);
    }
    
    /**
     * Main game update loop
     */
    update(timestamp) {
        if (!this.gameState.isRunning || this.gameState.isPaused) return;
        
        // Control game speed
        if (timestamp - this.lastMoveTime < this.gameSpeed) {
            this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
            return;
        }
        
        this.lastMoveTime = timestamp;
        
        // Update worm direction
        this.worm.direction = this.worm.nextDirection;
        
        // Move worm
        this.moveWorm();
        
        // Check collisions
        if (this.checkCollision()) {
            this.endGame();
            return;
        }
        
        // Check food collision
        this.checkFoodCollision();
        
        // Render
        this.render();
        
        // Continue game loop
        this.gameLoop = requestAnimationFrame((timestamp) => this.update(timestamp));
    }
    
    /**
     * Move the worm
     */
    moveWorm() {
        const head = { ...this.worm.body[0] };
        
        // Move head based on direction
        switch (this.worm.direction) {
            case 'up':
                head.y = (head.y - 1 + this.gridSize) % this.gridSize;
                break;
            case 'down':
                head.y = (head.y + 1) % this.gridSize;
                break;
            case 'left':
                head.x = (head.x - 1 + this.gridSize) % this.gridSize;
                break;
            case 'right':
                head.x = (head.x + 1) % this.gridSize;
                break;
        }
        
        // Add new head
        this.worm.body.unshift(head);
        
        // Remove tail (unless food was eaten)
        if (!this.checkFoodCollision()) {
            this.worm.body.pop();
        }
    }
    
    /**
     * Check for collisions (walls or self)
     */
    checkCollision() {
        const head = this.worm.body[0];
        
        // Check self collision (starting from index 1 to skip head)
        for (let i = 1; i < this.worm.body.length; i++) {
            if (head.x === this.worm.body[i].x && head.y === this.worm.body[i].y) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if worm ate food
     */
    checkFoodCollision() {
        const head = this.worm.body[0];
        
        if (head.x === this.food.x && head.y === this.food.y) {
            // Increase score
            this.score++;
            if (this.score > this.highScore) {
                this.highScore = this.score;
                this.saveHighScore();
            }
            
            // Update display
            this.updateScoreDisplay();
            
            // Generate new food
            this.generateFood();
            
            // Increase speed slightly
            this.gameSpeed = Math.max(50, this.gameSpeed - 2);
            
            return true;
        }
        
        return false;
    }
    
    /**
     * End the game
     */
    endGame() {
        this.gameState.isRunning = false;
        this.gameState.gameOver = true;
        
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
            this.gameLoop = null;
        }
        
        this.updateStatus(`Game Over! Final Score: ${this.score}`);
    }
    
    /**
     * Render the game
     */
    render() {
        // Clear canvas
        this.ctx.fillStyle = '#1f2937'; // bg-gray-800
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid (optional - for debugging)
        // this.drawGrid();
        
        // Draw worm
        this.drawWorm();
        
        // Draw food
        this.drawFood();
    }
    
    /**
     * Draw the worm
     */
    drawWorm() {
        this.ctx.fillStyle = '#10b981'; // text-green-500
        
        this.worm.body.forEach((segment, index) => {
            const x = segment.x * this.cellSize;
            const y = segment.y * this.cellSize;
            
            if (index === 0) {
                // Head - slightly larger and different color
                this.ctx.fillStyle = '#059669'; // text-green-600
                this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
            } else {
                // Body
                this.ctx.fillStyle = '#10b981'; // text-green-500
                this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
            }
        });
    }
    
    /**
     * Draw the food
     */
    drawFood() {
        const x = this.food.x * this.cellSize;
        const y = this.food.y * this.cellSize;
        
        this.ctx.fillStyle = '#ef4444'; // text-red-500
        this.ctx.beginPath();
        this.ctx.arc(
            x + this.cellSize / 2, 
            y + this.cellSize / 2, 
            this.cellSize / 2 - 1, 
            0, 
            2 * Math.PI
        );
        this.ctx.fill();
    }
    
    /**
     * Draw grid (for debugging)
     */
    drawGrid() {
        this.ctx.strokeStyle = '#374151'; // border-gray-700
        this.ctx.lineWidth = 0.5;
        
        for (let i = 0; i <= this.gridSize; i++) {
            // Vertical lines
            this.ctx.beginPath();
            this.ctx.moveTo(i * this.cellSize, 0);
            this.ctx.lineTo(i * this.cellSize, this.canvas.height);
            this.ctx.stroke();
            
            // Horizontal lines
            this.ctx.beginPath();
            this.ctx.moveTo(0, i * this.cellSize);
            this.ctx.lineTo(this.canvas.width, i * this.cellSize);
            this.ctx.stroke();
        }
    }
    
    /**
     * Update score display
     */
    updateScoreDisplay() {
        const scoreElement = document.getElementById('wormScore');
        const highScoreElement = document.getElementById('wormHighScore');
        
        if (scoreElement) {
            scoreElement.textContent = `Score: ${this.score}`;
        }
        
        if (highScoreElement) {
            highScoreElement.textContent = `High Score: ${this.highScore}`;
        }
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        const statusElement = document.getElementById('wormStatus');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }
}

// Initialize worm game when DOM is loaded
let wormGame;
document.addEventListener('DOMContentLoaded', () => {
    // Initialize calculator
    calculator = new Calculator();
    
    // Initialize worm game
    wormGame = new WormGame();
});

// ============================================================================
// END OF WORM GAME WIDGET
// ============================================================================ 