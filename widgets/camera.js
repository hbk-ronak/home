/**
 * ðŸ¤– AI-Generated Project: Minimalist Homepage
 * Generated by: Claude Sonnet 4 (Anthropic)
 * Date: 2024
 * Description: Camera Widget - Photo capture and download functionality
 * Tech Stack: Vanilla HTML/CSS/JS + Tailwind CSS
 * License: MIT
 */

// ============================================================================
// CAMERA WIDGET IMPLEMENTATION
// ============================================================================

/**
 * Camera Widget Class - Photo capture and download functionality
 */
class CameraWidget {
    constructor() {
        console.log('ðŸ“¸ Initializing Camera Widget...');
        
        // Camera elements
        this.video = null;
        this.canvas = null;
        this.stream = null;
        
        // Widget state
        this.isCameraActive = false;
        this.currentPhoto = null;
        
        // Settings (default only, no persistence)
        this.settings = {
            quality: 0.8,
            format: 'jpeg',
            filenameFormat: 'timestamp'
        };
        
        // Initialize the widget
        this.init();
    }
    
    /**
     * Initialize the camera widget
     */
    init() {
        this.setupElements();
        this.loadSettings();
        this.setupEventListeners();
        console.log('ðŸ“¸ Camera widget initialized');
    }
    
    /**
     * Setup DOM elements
     */
    setupElements() {
        this.video = document.getElementById('cameraVideo');
        this.canvas = document.getElementById('cameraCanvas');
        
        if (!this.video || !this.canvas) {
            console.error('âŒ Camera elements not found');
            return;
        }
        
        console.log('ðŸ“¸ Camera elements found:', !!this.video, !!this.canvas);
    }
    
    /**
     * Load camera settings from localStorage
     */
    loadSettings() {
        // Settings are now default-only, no persistence for privacy
        // Update UI to reflect default settings
        this.updateSettingsUI();
    }
    
    /**
     * Save camera settings to localStorage
     */
    saveSettings() {
        // Settings are no longer persisted for privacy reasons
        // This function is kept for compatibility but does nothing
    }
    
    /**
     * Update settings UI to reflect current settings
     */
    updateSettingsUI() {
        const qualitySelect = document.getElementById('photoQuality');
        const formatSelect = document.getElementById('photoFormat');
        const filenameSelect = document.getElementById('filenameFormat');
        
        if (qualitySelect) qualitySelect.value = this.settings.quality;
        if (formatSelect) formatSelect.value = this.settings.format;
        if (filenameSelect) filenameSelect.value = this.settings.filenameFormat;
    }
    
    /**
     * Setup event listeners
     */
    setupEventListeners() {
        // Camera controls
        const startBtn = document.getElementById('cameraStart');
        const captureBtn = document.getElementById('cameraCapture');
        const stopBtn = document.getElementById('cameraStop');
        const settingsBtn = document.getElementById('cameraSettings');
        
        if (startBtn) startBtn.addEventListener('click', () => this.startCamera());
        if (captureBtn) captureBtn.addEventListener('click', () => this.capturePhoto());
        if (stopBtn) stopBtn.addEventListener('click', () => this.stopCamera());
        if (settingsBtn) settingsBtn.addEventListener('click', () => this.toggleSettings());
        
        // Photo actions
        const downloadBtn = document.getElementById('downloadPhoto');
        const shareBtn = document.getElementById('sharePhoto');
        const retakeBtn = document.getElementById('retakePhoto');
        
        if (downloadBtn) downloadBtn.addEventListener('click', () => this.downloadPhoto());
        if (shareBtn) shareBtn.addEventListener('click', () => this.sharePhoto());
        if (retakeBtn) retakeBtn.addEventListener('click', () => this.retakePhoto());
        
        // Settings controls
        const qualitySelect = document.getElementById('photoQuality');
        const formatSelect = document.getElementById('photoFormat');
        const filenameSelect = document.getElementById('filenameFormat');
        
        if (qualitySelect) qualitySelect.addEventListener('change', (e) => {
            this.settings.quality = parseFloat(e.target.value);
            // Settings are no longer persisted for privacy
        });
        
        if (formatSelect) formatSelect.addEventListener('change', (e) => {
            this.settings.format = e.target.value;
            // Settings are no longer persisted for privacy
        });
        
        if (filenameSelect) filenameSelect.addEventListener('change', (e) => {
            this.settings.filenameFormat = e.target.value;
            // Settings are no longer persisted for privacy
        });
    }
    
    /**
     * Start camera stream
     */
    async startCamera() {
        try {
            console.log('ðŸ“¸ Starting camera...');
            
            // Request camera access
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'environment' // Prefer back camera on mobile
                }
            });
            
            // Set video source
            this.video.srcObject = this.stream;
            await this.video.play();
            
            // Wait for video to be ready
            await new Promise((resolve) => {
                this.video.addEventListener('loadedmetadata', resolve, { once: true });
            });
            
            // Update UI
            this.isCameraActive = true;
            this.showCameraActive();
            
            console.log('ðŸ“¸ Camera started successfully');
            
        } catch (error) {
            console.error('âŒ Camera start error:', error);
            this.showError('Failed to start camera. Please check permissions.');
        }
    }
    
    /**
     * Stop camera stream
     */
    stopCamera() {
        console.log('ðŸ“¸ Stopping camera...');
        
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        if (this.video) {
            this.video.srcObject = null;
        }
        
        this.isCameraActive = false;
        this.showCameraInactive();
        
        console.log('ðŸ“¸ Camera stopped');
    }
    
    /**
     * Capture photo from video stream
     */
    capturePhoto() {
        if (!this.isCameraActive || !this.video || !this.canvas) {
            console.warn('âš ï¸ Camera not active');
            return;
        }
        
        try {
            console.log('ðŸ“¸ Capturing photo...');
            
            // Wait for video to be ready
            if (this.video.videoWidth === 0 || this.video.videoHeight === 0) {
                console.warn('âš ï¸ Video not ready yet');
                return;
            }
            
            // Set canvas size to match video
            this.canvas.width = this.video.videoWidth;
            this.canvas.height = this.video.videoHeight;
            
            // Draw video frame to canvas
            const ctx = this.canvas.getContext('2d');
            ctx.drawImage(this.video, 0, 0);
            
            // Convert to blob
            this.canvas.toBlob((blob) => {
                if (blob) {
                    this.currentPhoto = blob;
                    this.showPhotoPreview(blob);
                    console.log('ðŸ“¸ Photo captured successfully');
                } else {
                    console.error('âŒ Failed to create photo blob');
                    this.showError('Failed to capture photo. Please try again.');
                }
            }, `image/${this.settings.format}`, this.settings.quality);
            
        } catch (error) {
            console.error('âŒ Photo capture error:', error);
            this.showError('Failed to capture photo. Please try again.');
        }
    }
    
    /**
     * Show photo preview
     */
    showPhotoPreview(blob) {
        const video = document.getElementById('cameraVideo');
        const previewDiv = document.getElementById('photoPreview');
        
        if (video && previewDiv) {
            // Create a new image element for the viewfinder
            const viewfinderImg = document.createElement('img');
            viewfinderImg.src = URL.createObjectURL(blob);
            viewfinderImg.className = 'w-full h-64 object-cover';
            viewfinderImg.alt = 'Photo preview';
            
            // Replace video with image in the viewfinder
            video.style.display = 'none';
            video.parentNode.insertBefore(viewfinderImg, video);
            
            // Store reference to the viewfinder image for cleanup
            this.viewfinderImage = viewfinderImg;
            
            // Hide camera controls when showing photo preview
            this.showPhotoPreviewState();
            
            // Show the photo actions (download/share buttons)
            previewDiv.classList.remove('hidden');
            
            // Clean up URL when image loads
            viewfinderImg.onload = () => {
                URL.revokeObjectURL(viewfinderImg.src);
            };
        }
    }
    
    /**
     * Download current photo
     */
    downloadPhoto() {
        if (!this.currentPhoto) {
            console.warn('âš ï¸ No photo to download');
            return;
        }
        
        try {
            console.log('ðŸ“¸ Downloading photo...');
            
            const filename = this.generateFilename();
            const url = URL.createObjectURL(this.currentPhoto);
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = filename;
            downloadLink.style.display = 'none';
            
            // Trigger download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // Clean up
            URL.revokeObjectURL(url);
            
            console.log('ðŸ“¸ Photo downloaded successfully');
            this.showSuccess('Photo downloaded successfully!');
            
            // Return to camera mode after download
            this.returnToCameraMode();
            
        } catch (error) {
            console.error('âŒ Download error:', error);
            this.showError('Failed to download photo. Please try again.');
        }
    }
    
    /**
     * Share current photo
     */
    async sharePhoto() {
        if (!this.currentPhoto) {
            console.warn('âš ï¸ No photo to share');
            return;
        }
        
        try {
            console.log('ðŸ“¸ Sharing photo...');
            
            // Check if Web Share API is available
            if ('share' in navigator && navigator.canShare) {
                const file = new File([this.currentPhoto], this.generateFilename(), {
                    type: `image/${this.settings.format}`
                });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file]
                        // Removed fixed title and text for privacy
                    });
                    console.log('ðŸ“¸ Photo shared successfully');
                    
                    // Return to camera mode after share
                    this.returnToCameraMode();
                    return;
                }
            }
            
            // Fallback to download
            console.log('ðŸ“¸ Web Share API not available, falling back to download');
            this.downloadPhoto();
            
        } catch (error) {
            console.error('âŒ Share error:', error);
            this.downloadPhoto(); // Fallback to download
        }
    }
    
    /**
     * Retake photo
     */
    retakePhoto() {
        console.log('ðŸ“¸ Retaking photo...');
        
        // Restore camera viewfinder
        const video = document.getElementById('cameraVideo');
        if (video && this.viewfinderImage) {
            // Remove the preview image
            this.viewfinderImage.remove();
            this.viewfinderImage = null;
            
            // Show video again
            video.style.display = 'block';
        }
        
        // Hide photo actions
        const previewDiv = document.getElementById('photoPreview');
        if (previewDiv) {
            previewDiv.classList.add('hidden');
        }
        
        // Restore camera controls if camera is still active
        if (this.isCameraActive) {
            this.showCameraActive();
        }
        
        // Clear current photo
        this.currentPhoto = null;
    }
    
    /**
     * Toggle settings panel
     */
    toggleSettings() {
        const settingsPanel = document.getElementById('cameraSettingsPanel');
        if (settingsPanel) {
            settingsPanel.classList.toggle('hidden');
        }
    }
    
    /**
     * Generate filename based on settings
     */
    generateFilename() {
        const now = new Date();
        const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' + 
                         now.toTimeString().split(' ')[0].replace(/:/g, '-');
        
        let filename;
        switch (this.settings.filenameFormat) {
            case 'timestamp':
                filename = `photo_${timestamp}`;
                break;
            case 'date-time':
                const dateTime = now.toLocaleString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                }).replace(/[/:]/g, '-').replace(/,/g, '');
                filename = `photo_${dateTime}`;
                break;
            case 'photo-number':
                // Removed photoCounter, so this case will always generate a default filename
                filename = `photo_${timestamp}`;
                break;
            default:
                filename = `photo_${timestamp}`;
        }
        
        return `${filename}.${this.settings.format}`;
    }
    
    /**
     * Add photo to session photos
     */
    addToSessionPhotos(blob, filename) {
        // Session photo storage removed for privacy reasons
        // This function is deprecated and will be removed in future versions
    }
    
    /**
     * Update recent photos grid
     */
    updateRecentPhotos() {
        // Session photo storage removed for privacy reasons
        // This function is deprecated and will be removed in future versions
    }
    
    /**
     * Show camera active state
     */
    showCameraActive() {
        const overlay = document.getElementById('cameraOverlay');
        const startBtn = document.getElementById('cameraStart');
        const captureBtn = document.getElementById('cameraCapture');
        const stopBtn = document.getElementById('cameraStop');
        
        if (overlay) overlay.classList.add('hidden');
        if (startBtn) startBtn.classList.add('hidden');
        if (captureBtn) captureBtn.classList.remove('hidden');
        if (stopBtn) stopBtn.classList.remove('hidden');
    }
    
    /**
     * Show camera inactive state
     */
    showCameraInactive() {
        const overlay = document.getElementById('cameraOverlay');
        const startBtn = document.getElementById('cameraStart');
        const captureBtn = document.getElementById('cameraCapture');
        const stopBtn = document.getElementById('cameraStop');
        
        if (overlay) overlay.classList.remove('hidden');
        if (startBtn) startBtn.classList.remove('hidden');
        if (captureBtn) captureBtn.classList.add('hidden');
        if (stopBtn) stopBtn.classList.add('hidden');
    }
    
    /**
     * Show photo preview state (hide camera controls)
     */
    showPhotoPreviewState() {
        const captureBtn = document.getElementById('cameraCapture');
        const stopBtn = document.getElementById('cameraStop');
        
        if (captureBtn) captureBtn.classList.add('hidden');
        if (stopBtn) stopBtn.classList.add('hidden');
    }
    
    /**
     * Show success message
     */
    showSuccess(message) {
        // Simple success feedback - could be enhanced with a toast notification
        console.log('âœ…', message);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Simple error feedback - could be enhanced with a toast notification
        console.error('âŒ', message);
        alert(message);
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        this.stopCamera();
        
        // Clean up viewfinder image if it exists
        if (this.viewfinderImage) {
            this.viewfinderImage.remove();
            this.viewfinderImage = null;
        }
        
        console.log('ðŸ“¸ Camera widget destroyed');
    }

    /**
     * Return to camera mode after photo action
     */
    returnToCameraMode() {
        // Restore camera viewfinder
        const video = document.getElementById('cameraVideo');
        if (video && this.viewfinderImage) {
            // Remove the preview image
            this.viewfinderImage.remove();
            this.viewfinderImage = null;
            
            // Show video again
            video.style.display = 'block';
        }
        
        // Hide photo actions
        const previewDiv = document.getElementById('photoPreview');
        if (previewDiv) {
            previewDiv.classList.add('hidden');
        }
        
        // Restore camera controls if camera is still active
        if (this.isCameraActive) {
            this.showCameraActive();
        }
        
        // Clear current photo
        this.currentPhoto = null;
    }
}

// Initialize camera widget when DOM is ready
let cameraWidget;
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        cameraWidget = new CameraWidget();
    });
} else {
    cameraWidget = new CameraWidget();
} 