/**
 * ðŸ¤– AI-Generated Project: Task Store Module
 * Generated by: Claude Sonnet 4 (Anthropic)
 * Date: 2024
 * Description: Centralized task data management for Calendar and To-Do integration
 * Tech Stack: Vanilla JavaScript + localStorage
 * License: MIT
 */

/**
 * TaskStore - Centralized task data management
 * Handles all task operations and provides a single source of truth
 * for both Calendar and To-Do widgets
 */
class TaskStore {
    constructor() {
        this.tasks = [];
        this.storageKey = 'homepage.tasks';
        this.loadTasks();
        this.migrateLegacyData();
    }

    /**
     * Loads tasks from localStorage
     */
    loadTasks() {
        try {
            const saved = localStorage.getItem(this.storageKey);
            if (saved) {
                this.tasks = JSON.parse(saved);
            }
        } catch (error) {
            console.error('Error loading tasks:', error);
            this.tasks = [];
        }
    }

    /**
     * Saves tasks to localStorage
     */
    saveTasks() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.tasks));
        } catch (error) {
            console.error('Error saving tasks:', error);
        }
    }

    /**
     * Migrates legacy todo data to new unified structure
     */
    migrateLegacyData() {
        try {
            // Check for legacy todo data
            const legacyTodos = localStorage.getItem('todoList');
            if (legacyTodos) {
                const legacyTasks = JSON.parse(legacyTodos);
                
                // Convert legacy tasks to new format
                const migratedTasks = legacyTasks.map(task => ({
                    id: task.id,
                    text: task.text,
                    completed: task.completed,
                    dueDate: null, // Legacy tasks have no due date
                    createdAt: new Date().toISOString() // Set current time as creation date
                }));

                // Add migrated tasks to current tasks (avoid duplicates)
                const existingIds = new Set(this.tasks.map(t => t.id));
                const newTasks = migratedTasks.filter(task => !existingIds.has(task.id));
                
                if (newTasks.length > 0) {
                    this.tasks.push(...newTasks);
                    this.saveTasks();
                    console.log(`Migrated ${newTasks.length} legacy tasks`);
                }

                // Remove legacy data
                localStorage.removeItem('todoList');
            }
        } catch (error) {
            console.error('Error migrating legacy data:', error);
        }
    }

    /**
     * Gets all tasks
     * @returns {Array} Array of all tasks
     */
    getTasks() {
        return [...this.tasks]; // Return copy to prevent direct mutation
    }

    /**
     * Gets tasks filtered by date
     * @param {string} dateStr - Date in 'YYYY-MM-DD' format
     * @returns {Array} Array of tasks for the specified date
     */
    getTasksByDate(dateStr) {
        return this.tasks.filter(task => task.dueDate === dateStr);
    }

    /**
     * Gets tasks for today
     * @returns {Array} Array of tasks due today
     */
    getTasksForToday() {
        const today = new Date().toISOString().split('T')[0]; // 'YYYY-MM-DD'
        return this.getTasksByDate(today);
    }

    /**
     * Gets tasks with due dates
     * @returns {Array} Array of tasks that have due dates
     */
    getDatedTasks() {
        return this.tasks.filter(task => task.dueDate !== null);
    }

    /**
     * Gets tasks without due dates
     * @returns {Array} Array of tasks without due dates
     */
    getUndatedTasks() {
        return this.tasks.filter(task => task.dueDate === null);
    }

    /**
     * Adds a new task
     * @param {Object} taskData - Task data object
     * @param {string} taskData.text - Task text
     * @param {string|null} taskData.dueDate - Due date in 'YYYY-MM-DD' format (optional)
     * @returns {Object} The created task object
     */
    addTask(taskData) {
        const task = {
            id: this.generateId(),
            text: taskData.text.trim(),
            completed: false,
            dueDate: taskData.dueDate || null,
            createdAt: new Date().toISOString()
        };

        this.tasks.push(task);
        this.saveTasks();
        return task;
    }

    /**
     * Updates an existing task
     * @param {string} taskId - Task ID to update
     * @param {Object} fields - Fields to update
     * @returns {Object|null} Updated task object or null if not found
     */
    updateTask(taskId, fields) {
        const taskIndex = this.tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) return null;

        // Update only allowed fields
        const allowedFields = ['text', 'completed', 'dueDate'];
        allowedFields.forEach(field => {
            if (fields.hasOwnProperty(field)) {
                this.tasks[taskIndex][field] = fields[field];
            }
        });

        this.saveTasks();
        return { ...this.tasks[taskIndex] };
    }

    /**
     * Deletes a task
     * @param {string} taskId - Task ID to delete
     * @returns {boolean} True if task was deleted, false if not found
     */
    deleteTask(taskId) {
        const initialLength = this.tasks.length;
        this.tasks = this.tasks.filter(t => t.id !== taskId);
        
        if (this.tasks.length !== initialLength) {
            this.saveTasks();
            return true;
        }
        return false;
    }

    /**
     * Toggles task completion status
     * @param {string} taskId - Task ID to toggle
     * @returns {Object|null} Updated task object or null if not found
     */
    toggleTask(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return null;

        return this.updateTask(taskId, { completed: !task.completed });
    }

    /**
     * Generates a unique ID for tasks
     * @returns {string} Unique ID
     */
    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    /**
     * Deletes all tasks for a specific date
     * @param {string} dateStr - Date in 'YYYY-MM-DD' format
     * @returns {number} Number of tasks deleted
     */
    deleteTasksForDate(dateStr) {
        const initialLength = this.tasks.length;
        this.tasks = this.tasks.filter(task => task.dueDate !== dateStr);
        
        const deletedCount = initialLength - this.tasks.length;
        if (deletedCount > 0) {
            this.saveTasks();
        }
        return deletedCount;
    }

    /**
     * Adds multiple tasks for a specific date
     * @param {string} dateStr - Date in 'YYYY-MM-DD' format
     * @param {Array} taskDataArray - Array of task data objects
     * @returns {Array} Array of created task objects
     */
    addTasksForDate(dateStr, taskDataArray) {
        const createdTasks = [];
        
        taskDataArray.forEach(taskData => {
            const task = {
                id: this.generateId(),
                text: taskData.text.trim(),
                completed: taskData.completed || false,
                dueDate: dateStr,
                createdAt: new Date().toISOString()
            };
            
            this.tasks.push(task);
            createdTasks.push(task);
        });
        
        this.saveTasks();
        return createdTasks;
    }

    /**
     * Gets task statistics
     * @returns {Object} Task statistics
     */
    getStats() {
        const total = this.tasks.length;
        const completed = this.tasks.filter(t => t.completed).length;
        const pending = total - completed;
        const dated = this.getDatedTasks().length;
        const undated = this.getUndatedTasks().length;
        const today = this.getTasksForToday().length;

        return {
            total,
            completed,
            pending,
            dated,
            undated,
            today
        };
    }

    /**
     * Clears all tasks
     */
    clearAllTasks() {
        this.tasks = [];
        this.saveTasks();
    }

    /**
     * Exports tasks as JSON
     * @returns {string} JSON string of all tasks
     */
    exportTasks() {
        return JSON.stringify(this.tasks, null, 2);
    }

    /**
     * Imports tasks from JSON
     * @param {string} jsonString - JSON string of tasks
     * @returns {boolean} True if import was successful
     */
    importTasks(jsonString) {
        try {
            const importedTasks = JSON.parse(jsonString);
            if (Array.isArray(importedTasks)) {
                this.tasks = importedTasks;
                this.saveTasks();
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error importing tasks:', error);
            return false;
        }
    }
}

// Create global task store instance
window.taskStore = new TaskStore();

// Export for module usage (if needed)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TaskStore;
} 