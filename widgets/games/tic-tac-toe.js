/**
 * 🤖 AI-Generated Project: Minimalist Homepage
 * Generated by: Claude Sonnet 4 (Anthropic)
 * Date: 2024
 * Description: Tic-Tac-Toe Game Implementation - Classic 3x3 grid game
 * Tech Stack: Vanilla HTML/CSS/JS + Tailwind CSS
 * License: MIT
 */

// ============================================================================
// TIC-TAC-TOE GAME IMPLEMENTATION
// ============================================================================

/**
 * Tic-Tac-Toe Game Class - A classic 3x3 grid game
 */
class TicTacToe {
    constructor() {
        console.log('🎮 Initializing Tic-Tac-Toe Game...');
        
        this.canvas = document.getElementById('wormCanvas'); // Reuse the same canvas
        console.log('🎮 Canvas element found:', !!this.canvas);
        
        if (!this.canvas) {
            console.error('❌ Canvas not found!');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        console.log('🎮 Canvas context created:', !!this.ctx);
        
        // Game state
        this.gameState = {
            isRunning: false,
            gameOver: false,
            winner: null,
            isDraw: false
        };
        
        // Board state (3x3 grid)
        this.board = [
            ['', '', ''],
            ['', '', ''],
            ['', '', '']
        ];
        
        // Game settings
        this.currentPlayer = 'X'; // X goes first
        this.gridSize = 3; // 3x3 grid
        this.cellSize = 100; // 100px per cell (300px canvas / 3)
        this.score = {
            X: 0,
            O: 0,
            draws: 0
        };
        
        // Initialize the game
        this.init();
    }
    
    /**
     * Initialize the game
     */
    init() {
        this.setupCanvas();
        this.loadScores();
        this.setupEventListeners();
        this.resetGame();
        this.render();
    }
    
    /**
     * Setup canvas for tic-tac-toe
     */
    setupCanvas() {
        console.log('🎨 Setting up tic-tac-toe canvas...');
        
        // Set canvas size
        this.canvas.width = 300;
        this.canvas.height = 300;
        
        console.log('🎨 Canvas size set to:', this.canvas.width, 'x', this.canvas.height);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.render();
        });
    }
    
    /**
     * Load scores from localStorage
     */
    loadScores() {
        const saved = localStorage.getItem('tictactoeScores');
        if (saved) {
            this.score = JSON.parse(saved);
        }
        // Don't update display here - game manager handles it when switching games
    }
    
    /**
     * Save scores to localStorage
     */
    saveScores() {
        localStorage.setItem('tictactoeScores', JSON.stringify(this.score));
    }
    
    /**
     * Setup event listeners for controls
     */
    setupEventListeners() {
        // Canvas click handling
        this.canvas.addEventListener('click', (e) => {
            if (this.gameState.gameOver) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert to grid coordinates
            const gridX = Math.floor(x / this.cellSize);
            const gridY = Math.floor(y / this.cellSize);
            
            if (gridX >= 0 && gridX < 3 && gridY >= 0 && gridY < 3) {
                this.makeMove(gridX, gridY);
            }
        });
        
        // Game control buttons
        document.getElementById('wormStart').addEventListener('click', () => {
            this.startGame();
        });
        
        document.getElementById('wormRestart').addEventListener('click', () => {
            this.resetGame();
        });
        
        // Keyboard controls for accessibility
        document.addEventListener('keydown', (e) => {
            if (this.gameState.gameOver) return;
            
            // Number keys 1-9 for grid positions
            const keyMap = {
                '1': [0, 0], '2': [1, 0], '3': [2, 0],
                '4': [0, 1], '5': [1, 1], '6': [2, 1],
                '7': [0, 2], '8': [1, 2], '9': [2, 2]
            };
            
            if (keyMap[e.key]) {
                const [x, y] = keyMap[e.key];
                this.makeMove(x, y);
            }
        });
    }
    
    /**
     * Make a move at the specified position
     * @param {number} x - Grid X coordinate
     * @param {number} y - Grid Y coordinate
     */
    makeMove(x, y) {
        if (this.gameState.gameOver || this.board[y][x] !== '') {
            return; // Invalid move
        }
        
        // Place the mark
        this.board[y][x] = this.currentPlayer;
        console.log(`🎯 ${this.currentPlayer} placed at (${x}, ${y})`);
        
        // Check for win
        if (this.checkWin(x, y)) {
            this.endGame(this.currentPlayer);
            return;
        }
        
        // Check for draw
        if (this.isBoardFull()) {
            this.endGame('draw');
            return;
        }
        
        // Switch players
        this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
        
        // Render the updated board
        this.render();
        this.updateStatus(`${this.currentPlayer}'s turn`);
    }
    
    /**
     * Check if the last move resulted in a win
     * @param {number} x - Last move X coordinate
     * @param {number} y - Last move Y coordinate
     * @returns {boolean} True if the move resulted in a win
     */
    checkWin(x, y) {
        const player = this.board[y][x];
        
        // Check row
        if (this.board[y].every(cell => cell === player)) {
            return true;
        }
        
        // Check column
        if (this.board.every(row => row[x] === player)) {
            return true;
        }
        
        // Check diagonals
        if (x === y && this.board[0][0] === player && 
            this.board[1][1] === player && this.board[2][2] === player) {
            return true;
        }
        
        if (x + y === 2 && this.board[0][2] === player && 
            this.board[1][1] === player && this.board[2][0] === player) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if the board is full (draw)
     * @returns {boolean} True if board is full
     */
    isBoardFull() {
        return this.board.every(row => row.every(cell => cell !== ''));
    }
    
    /**
     * Start the game
     */
    startGame() {
        if (this.gameState.isRunning) return;
        
        this.gameState.isRunning = true;
        this.gameState.gameOver = false;
        this.gameState.winner = null;
        this.gameState.isDraw = false;
        
        this.updateStatus(`${this.currentPlayer}'s turn`);
    }
    
    /**
     * Reset the game
     */
    resetGame() {
        console.log('🔄 Resetting tic-tac-toe game...');
        
        // Reset game state
        this.gameState.isRunning = false;
        this.gameState.gameOver = false;
        this.gameState.winner = null;
        this.gameState.isDraw = false;
        
        // Reset board
        this.board = [
            ['', '', ''],
            ['', '', ''],
            ['', '', '']
        ];
        
        // Reset current player
        this.currentPlayer = 'X';
        
        console.log('🎯 Board reset, current player:', this.currentPlayer);
        
        // Update displays
        this.updateStatus('Press Start to begin');
        
        // Render initial state
        this.render();
    }
    
    /**
     * End the game
     * @param {string} result - 'X', 'O', or 'draw'
     */
    endGame(result) {
        this.gameState.gameOver = true;
        this.gameState.isRunning = false;
        
        if (result === 'draw') {
            this.gameState.isDraw = true;
            this.score.draws++;
            this.updateStatus('Game Over - Draw!');
        } else {
            this.gameState.winner = result;
            this.score[result]++;
            this.updateStatus(`Game Over - ${result} wins!`);
        }
        
        this.saveScores();
        // Update score display using the game manager
        if (typeof window.updateGameScoreDisplay === 'function') {
            window.updateGameScoreDisplay();
        }
        this.render();
    }
    
    /**
     * Render the game
     */
    render() {
        console.log('🔄 Rendering tic-tac-toe game...');
        
        // Clear canvas
        this.ctx.fillStyle = '#1f2937'; // bg-gray-800
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        console.log('🎨 Canvas cleared, drawing tic-tac-toe board');
        
        // Draw grid
        this.drawGrid();
        
        // Draw marks
        this.drawMarks();
        
        // Draw win line if game is over
        if (this.gameState.gameOver && this.gameState.winner) {
            this.drawWinLine();
        }
        
        console.log('✅ Tic-tac-toe game render complete');
    }
    
    /**
     * Draw the grid lines
     */
    drawGrid() {
        this.ctx.strokeStyle = '#6b7280'; // text-gray-500
        this.ctx.lineWidth = 2;
        
        // Vertical lines
        for (let i = 1; i < 3; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(i * this.cellSize, 0);
            this.ctx.lineTo(i * this.cellSize, this.canvas.height);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let i = 1; i < 3; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, i * this.cellSize);
            this.ctx.lineTo(this.canvas.width, i * this.cellSize);
            this.ctx.stroke();
        }
    }
    
    /**
     * Draw X and O marks
     */
    drawMarks() {
        this.ctx.lineWidth = 3;
        this.ctx.font = 'bold 60px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        for (let y = 0; y < 3; y++) {
            for (let x = 0; x < 3; x++) {
                const cell = this.board[y][x];
                if (cell === '') continue;
                
                const centerX = x * this.cellSize + this.cellSize / 2;
                const centerY = y * this.cellSize + this.cellSize / 2;
                
                if (cell === 'X') {
                    // Draw X
                    this.ctx.strokeStyle = '#ef4444'; // text-red-500
                    this.ctx.fillStyle = '#ef4444';
                    this.ctx.fillText('X', centerX, centerY);
                } else if (cell === 'O') {
                    // Draw O
                    this.ctx.strokeStyle = '#3b82f6'; // text-blue-500
                    this.ctx.fillStyle = '#3b82f6';
                    this.ctx.fillText('O', centerX, centerY);
                }
            }
        }
    }
    
    /**
     * Draw win line (placeholder - would highlight winning combination)
     */
    drawWinLine() {
        // This would draw a line through the winning combination
        // For now, we'll just add a visual indicator
        this.ctx.strokeStyle = '#10b981'; // text-green-500
        this.ctx.lineWidth = 4;
        this.ctx.setLineDash([5, 5]);
        
        // Draw a border around the winning cells
        // This is a simplified version - in a full implementation,
        // you'd calculate the exact winning line
        this.ctx.strokeRect(5, 5, this.canvas.width - 10, this.canvas.height - 10);
        this.ctx.setLineDash([]);
    }
    
    /**
     * Update score display
     */
    updateScoreDisplay() {
        const scoreElement = document.getElementById('wormScore');
        const highScoreElement = document.getElementById('wormHighScore');
        
        if (scoreElement) {
            scoreElement.textContent = `X: ${this.score.X} | O: ${this.score.O}`;
        }
        
        if (highScoreElement) {
            highScoreElement.textContent = `Draws: ${this.score.draws}`;
        }
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        const statusElement = document.getElementById('wormStatus');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }
    
    /**
     * Clean up game resources
     */
    destroy() {
        // Remove event listeners
        // Note: In a more sophisticated implementation, we'd store references to event listeners
        // and remove them properly. For now, we'll rely on the fact that the game manager
        // will handle the overall widget lifecycle.
    }
    
    /**
     * Static method to create a new tic-tac-toe game instance
     * @returns {TicTacToe} New tic-tac-toe game instance
     */
    static create() {
        return new TicTacToe();
    }
}

// Export the class for the game manager to use
window.TicTacToe = TicTacToe;

// Note: Tic-tac-toe will be initialized when selected from the game dropdown
// No auto-initialization needed since it's not the default game 